pipeline {
  agent any

  environment {
    DOCKER_DEFAULT_TAG                     = "latest"
    VALID_TAG_REGEX                        = "v[0-9]+\\.[0-9]+\\.[0-9]+(-(beta|rc)\\.[0-9]+)?"  // patern matches 'v<semver>' with optional suffix of '-beta.<number>' or '-rc.<number>'
    DOCKER_IMAGE_REGISTRIES_CREDENTIALS_ID = "docker-registries-config"  // TODO: once two-way replication is setup add harbor-pdc auth to credential in jenkins
    // DOCKER_IMAGE_NAME_WITH_REGISTRY_A      = "${env.JENKINS_URL.split('/')[2].startsWith('nbuprod') ? 'harbor.mellanox.com' : 'harbor-pdc.nvidia.com'}/cloud-orchestration-dev/network-operator"  // TODO: once two-way replication is setup, use this dynamic environment variable
    DOCKER_IMAGE_NAME_WITH_REGISTRY_A      = "harbor.mellanox.com/cloud-orchestration-dev/network-operator-mzeevi-test"  // TODO: remove '-mzeevi-test' suffix before merging to master
    DOCKER_IMAGE_NAME_WITH_REGISTRY_B      = "nvcr.io/nvstaging/mellanox/network-operator-mzeevi-test"                   // TODO: remove '-mzeevi-test' suffix before merging to master
    KANIKO_ARGS                            = "--registry-mirror dockerhub.nvidia.com --registry-mirror dockerhub-backup.nvidia.com"
  }

  options {
    timeout(time: 30, unit: "MINUTES")
  }

  stages {
    stage("Determine Docker tags") {
      steps {
        sh("git fetch --force --tags $env.GIT_URL HEAD")
        script {
          GIT_COMMIT_SHORT = sh(script: "git log -n 1 --format=%h", returnStdout: true).trim()
          GIT_TAG          = sh(script: "git describe --tags --exact-match | grep -E '$env.VALID_TAG_REGEX' || true", returnStdout: true).trim()
        }
        echo("Docker image will use the tags: $DOCKER_DEFAULT_TAG $GIT_COMMIT_SHORT $GIT_TAG")
      }
    }

    stage("Multi-architecture build") {
      matrix {
        axes {
          axis {
            name "ARCH"
            values "amd64", "arm64"
          }
        }
        stages {
          stage("Build and push image") {
            agent {
              kubernetes {
                yamlFile "ci/agent-kaniko-${ARCH}.yaml"
                defaultContainer "kaniko"
              }
            }
            steps {
              withCredentials([file(credentialsId: "$env.DOCKER_IMAGE_REGISTRIES_CREDENTIALS_ID", variable: "DOCKER_CONFIG_FILE")]) {
                sh("cp $DOCKER_CONFIG_FILE /kaniko/.docker/config.json")
              }
              sh("""
                /kaniko/executor \
                  $env.KANIKO_ARGS \
                  --context . \
                  --destination $env.DOCKER_IMAGE_NAME_WITH_REGISTRY_A:$GIT_COMMIT_SHORT-$ARCH \
                  --destination $env.DOCKER_IMAGE_NAME_WITH_REGISTRY_B:$GIT_COMMIT_SHORT-$ARCH \
              """)
            }
          }
        }
      }
    }

    stage("Create manifest package") {
      agent {
        kubernetes {
          yamlFile "ci/agent-manifest-tool.yaml"
          defaultContainer "manifest-tool"
        }
      }
      steps {
        script {
          withCredentials([file(credentialsId: env.DOCKER_IMAGE_REGISTRIES_CREDENTIALS_ID, variable: "DOCKER_CONFIG_FILE")]) {
            for (DOCKER_IMAGE_NAME_WITH_REGISTRY in [env.DOCKER_IMAGE_NAME_WITH_REGISTRY_A, env.DOCKER_IMAGE_NAME_WITH_REGISTRY_B]) {
              sh("""
                manifest-tool \
                  --docker-cfg $DOCKER_CONFIG_FILE \
                  push from-args \
                  --platforms  linux/amd64,linux/arm64 \
                  --template   $DOCKER_IMAGE_NAME_WITH_REGISTRY:$GIT_COMMIT_SHORT-ARCH \
                  --target     $DOCKER_IMAGE_NAME_WITH_REGISTRY:$GIT_COMMIT_SHORT \
                  --tags       $DOCKER_DEFAULT_TAG \
                  ${GIT_TAG ? "--tags $GIT_TAG" : ""} \
              """)
            }
          }
        }
      }
    }
  }
}
